---
author: hongbo
date: "2020-09-26" 
previewImg:
category: compiler
title: What's new in ReScript 8.3 (Part 2)
description: |
---

## Introduction

ReScript is a soundly typed language with an optimizing compiler focused on the JS platform. 
It's focused on type safety, performance and JS interop. It used to be called BuckleScript.

[ReScript@8.3](https://www.npmjs.com/package/bs-platform/v/8.3.0) is now available for testing, you can try it via

```
npm i bs-platform@8.3.0
```

Following the [previous post](/blog/release-8-3-pt1), in this post we will go through 
the enhancement over the build system.

## Performance enhancement

The underlying build engine for `bsb` is [ninja](https://ninja-build.org/), it is famous for 
[being fast](https://www.aosabook.org/en/posa/ninja.html)
to build large C++ repos.

In the last releases, we did lots of work for vertical integration into the bsb build chain. 
For example, we replaced the dynamic dependency parser with a minimal specialized one for bsb.
we also removed the static dependencies parser which is only used for parsing C++ compiler output.

Thanks to various other low-level improvements, the final outcome is quite impressive.
For example, The binary size for [Mac platform](https://github.com/ninja-build/ninja/releases/tag/v1.10.1) is 270 KB
while our vendored version is only 136KB. This is a non-trivial gain given that ninja is minimalist and already 
optimized by top-level C++ experts.

Note such vertical integration not only brings better performance, smaller sizes, it also brings new features 
we will discuss soon.

## Build system output as editor diagnostics

When people are coding in their favorite editors, they expect the editor to deliver the feedback loop in real-time, for example, 
what syntax errors, type checking errors do they have when editing? There are multiple ways to achieve this, the most easy 
and reliable way is to always invoke the build system whenever the user saves the files, since it's the same build system 
without any in-memory cache, the reliability is very high, however, there's several challenges to use the build system output as editor diagnostics.

### The build system/compiler has to be fast to deliver feedback loop in one hundred milliseconds for typical projects

Our build system is fast enough to deliver feedback loop for reasonable sizes of projects, 
thanks to our previous [hard work](/blog/scalable). We continue improving 
the build performance during each release, we believe such approach is reliable using our build tools.

### The warnings for each file should not be flushed during a rebuild

For a typical file based build system, if the file A is compiled successfully with some warnings, the rebuild will not build A anymore.
This is problematic if we use the build system output as editor diagnostics. Since the second build will not capture those warnings, we 
could use some caching mechanism to cache previous build output, but it will render such system stateful and not reliable.

To solve such challenging problem, we did some innovations to co-ordinate the compiler and build system. When the file A is compiled with warnings, 
the compiler will produce some marks to the build system, the build system will keep building but such marks are encoded in the build rules
so that the second build will do the rebuild.

The benefit is two fold:

- Rebuild will re-capture those warnings
- Rebuild will be fast since only those files with warnings get rebuilt, it will not trigger unnecessary builds since our build is [content-based](https://rescript-lang.org/blog/scalable) build system.

The integration between compiler and build system is encoded in a specialized protocol so that this new feature's almost cost-free.

### A tiny client notification via .comipler.log

To get the build output, instead of communicating with IPC, we adopted a simple protocol, whenever a build is done, we wrote the output to a file called `.compiler.log`.
This makes the editor integration build-system agnostic, it does not need talk to the build system directly.

It also makes our build tool can work with other watchers including Facebook's [watchman](https://facebook.github.io/watchman/).
Watchman is  a more scalable watcher tool for specific platform and less memory hungry, however, we still need a watchman-client to get the output of triggerred job.
Now since we write the output to `.compiler.log` per each build, such client is available for free.

## A better algorithm for removing stale outputs

Whenever we do some renaming from `a.res` to `b.res`, the output caused by `a.res` will be stale output. Thanks to the deeper integration of the build system and compiler, 
we employ a more advanced strategy to remove stale outputs in this release, such pruning stale outputs is done in the beginning of each build.

There're two  ways of removing staled artifacts, the second one is introduced in this release:

- Based on live analysis and  prebuilt-in knowledge

We scan `lib/bs` directory and check some dangling cm{i,t,j,ti} files, if it does not exist in 
the current build set, it is considered stale artifacts. If it is `cmt` file, it would trigger some hooks of `genType`, notably -cmt-rm. 

- Based on previous build logs
We stored previous compilation stats, so that for a file, if it is previous output, but no longer a output of the new build, 
it is considered stale output which can be removed.

In general, the new introduced strategy 2 is more reliable and efficient.

- We don't need redo the path calculate since it's already done by the build system.
- When we change the in-source build to out-source build, it will still do the pruning properly

however, the former could be more customized for other buid system not aware systems including `genType`,
we employ a combination of the two strategies.

When removing js outputs, we use strategy two, when removing .cm* files, we use the first strategy.



Happy Hacking!
